Timer unit: 1e-06 s

Total time: 10.4825 s
File: /home/uash/JupyterWorkspace/Library/Ikamoana/ikamoana/ikamoanafields/ikamoanafields.py
Function: gradient at line 94

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    94                                               def gradient(self,
    95                                                            field: xr.DataArray,
    96                                                            landmask: xr.DataArray) -> Tuple[xr.DataArray]:
    97                                           
    98                                                   """
    99                                                   Gradient calculation for a Xarray DataArray seapodym-equivalent calculation
   100                                                   requires LandMask forward and backward differencing for domain edges
   101                                                   and land/shallow sea cells.
   102                                                   """
   103                                           
   104         2        474.0    237.0      0.0          if ((field.lat.size != landmask.lat.size)
   105         1        318.0    318.0      0.0                  or (field.lon.size != landmask.lon.size)) :
   106                                                       raise ValueError("Field and landmask must have the same dimension.")
   107                                           
   108         1          3.0      3.0      0.0          def getCellEdgeSizes(field) :
   109                                                       """Copy of the Field.calc_cell_edge_sizes() function in Parcels.
   110                                                       Avoid the convertion of DataArray into Field."""
   111                                                       
   112                                                       ## NOTE : Verify if reindex will impact dx and dy 
   113                                                       if field.lat[0] > field.lat[-1] :
   114                                                           field = field.reindex(lat=list(reversed(field.lat)))
   115                                                       
   116                                                       field_grid = parcels.grid.RectilinearZGrid(
   117                                                           field.lon.data, field.lat.data,
   118                                                           depth=None, time=None, time_origin=None,
   119                                                           mesh='spherical') # In degrees
   120                                           
   121                                                       field_grid.cell_edge_sizes['x'] = np.zeros((field_grid.ydim, field_grid.xdim), dtype=np.float32)
   122                                                       field_grid.cell_edge_sizes['y'] = np.zeros((field_grid.ydim, field_grid.xdim), dtype=np.float32)
   123                                           
   124                                                       # x_conv = GeographicPolar() if field_grid.mesh == 'spherical' else UnitConverter()
   125                                                       # y_conv = Geographic() if self.grid.mesh == 'spherical' else UnitConverter()
   126                                                       x_conv = GeographicPolar()
   127                                                       y_conv = Geographic()
   128                                           
   129                                                       for y, (lat, dlat) in enumerate(zip(field_grid.lat, np.gradient(field_grid.lat))):
   130                                                           for x, (lon, dlon) in enumerate(zip(field_grid.lon, np.gradient(field_grid.lon))):
   131                                                               field_grid.cell_edge_sizes['x'][y, x] = x_conv.to_source(dlon, lon, lat, field_grid.depth[0])
   132                                                               field_grid.cell_edge_sizes['y'][y, x] = y_conv.to_source(dlat, lon, lat, field_grid.depth[0])
   133                                                       
   134                                                       return field_grid.cell_edge_sizes['x'], field_grid.cell_edge_sizes['y']
   135                                           
   136         1     197464.0 197464.0      1.9          dlon, dlat = getCellEdgeSizes(field)
   137                                                   
   138         1        225.0    225.0      0.0          nlat = field.lat.size
   139         1        215.0    215.0      0.0          nlon = field.lon.size
   140                                           
   141         1        158.0    158.0      0.0          data = np.nan_to_num(field.data)
   142         1         13.0     13.0      0.0          dVdlon = np.zeros(data.shape, dtype=np.float32)
   143         1          4.0      4.0      0.0          dVdlat = np.zeros(data.shape, dtype=np.float32)
   144                                           
   145                                                   # # Already exchange lat and lon in landmask functions
   146                                                   # landmask = np.transpose(landmask.data[0,:,:])
   147                                           
   148                                                   # X = nlon if nlon <= landmask.shape[0] else landmask.shape[0]
   149                                                   # Y = nlat if nlat <= landmask.shape[1] else landmask.shape[1]
   150                                           
   151                                                   ## NOTE : Parallelised execution may help to do it faster.
   152         2        198.0     99.0      0.0          for t in range(field.time.size):
   153       100        167.0      1.7      0.0              for lon in range(1, nlon-1):
   154                                                           ## NOTE : Be carefull, reindex (in getCellEdgeSizes) probably reverse Latitude order
   155      5841      14036.0      2.4      0.1                  for lat in range(1, nlat-1):
   156      5742    2888254.0    503.0     27.6                      if landmask[lat, lon] < 1:
   157                                           
   158      3376    1808521.0    535.7     17.3                          if landmask[lat, lon+1] == 1:
   159        37        216.0      5.8      0.0                              dVdlon[t,lat,lon] = (data[t,lat,lon] - data[t,lat,lon-1]) / dlon[lat, lon]
   160      3339    1792998.0    537.0     17.1                          elif landmask[lat, lon-1] == 1:
   161        27        196.0      7.3      0.0                              dVdlon[t,lat,lon] = (data[t,lat,lon+1] - data[t,lat,lon]) / dlon[lat, lon]
   162                                                                   else:
   163      3312      75106.0     22.7      0.7                              dVdlon[t,lat,lon] = (data[t,lat,lon+1] - data[t,lat,lon-1]) / (2*dlon[lat, lon])
   164                                           
   165      3376    1822655.0    539.9     17.4                          if landmask[lat+1, lon] == 1:
   166        11         66.0      6.0      0.0                              dVdlat[t,lat,lon] = (data[t,lat,lon] - data[t,lat-1,lon]) / dlat[lat, lon]
   167      3365    1805149.0    536.4     17.2                          elif landmask[lat-1, lon] == 1:
   168        46        285.0      6.2      0.0                              dVdlat[t,lat,lon] = (data[t,lat+1,lon] - data[t,lat,lon]) / dlat[lat, lon]
   169                                                                   else:
   170      3319      72143.0     21.7      0.7                              dVdlat[t,lat,lon] = (data[t,lat+1,lon] - data[t,lat-1,lon]) / (2*dlat[lat, lon])
   171                                           
   172        99        460.0      4.6      0.0                  dVdlat[t, 0, lon] = (data[t, 1, lon] - data[t, 0, lon]) / dlat[0, lon]
   173        99        288.0      2.9      0.0                  dVdlat[t, -1, lon] = (data[t, -1, lon] - data[t, -2, lon]) / dlat[-2, lon]
   174                                           
   175        61        129.0      2.1      0.0              for lat in range(nlat):
   176        60        214.0      3.6      0.0                  dVdlon[t, lat, 0] = (data[t, lat, 1] - data[t, lat, 0]) / dlon[lat, lon]
   177        60        232.0      3.9      0.0                  dVdlon[t, lat, -1] = (data[t, lat, -1] - data[t, lat, -2]) / dlon[lat, lon]
   178                                           
   179         1         55.0     55.0      0.0          assert not (True in np.isnan(dVdlon))
   180         1         20.0     20.0      0.0          assert not (True in np.isnan(dVdlat))
   181                                           
   182         1          3.0      3.0      0.0          return (
   183         2       1170.0    585.0      0.0              xr.DataArray(
   184         1          7.0      7.0      0.0                  name = 'd' + field.name + '_dlon',
   185         1          1.0      1.0      0.0                  data = dVdlon,
   186         1          5.0      5.0      0.0                  coords = field.coords,
   187         1          2.0      2.0      0.0                  dims=('time','lat','lon'),
   188         1          6.0      6.0      0.0                  attrs=field.attrs
   189                                                       ),
   190         2       1076.0    538.0      0.0              xr.DataArray(
   191         1          3.0      3.0      0.0                  name = 'd' + field.name + '_dlat',
   192         1          1.0      1.0      0.0                  data = dVdlat,
   193         1          4.0      4.0      0.0                  coords = field.coords,
   194         1          1.0      1.0      0.0                  dims=('time','lat','lon'),
   195         1          5.0      5.0      0.0                  attrs=field.attrs
   196                                                       )
   197                                                   )